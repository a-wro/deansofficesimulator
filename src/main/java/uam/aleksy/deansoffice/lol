package uam.aleksy.deansoffice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import uam.aleksy.deansoffice.data.Applicant;
import uam.aleksy.deansoffice.data.Employee;
import uam.aleksy.deansoffice.data.Task;

import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@SpringBootApplication
public class DeansofficeApplication {

    private static final int NUM_OF_APPLICANTS = 100;

    private static final int NUM_OF_EMPLOYEES = 10;

    private static final int EMPLOYEE_ENERGY = 4;

    // data
//    @Autowired
    private static OfficeQueue queue;

    private static List<Employee> employees = new ArrayList<>();

    // stores which applicant is served by which employee
    private static Map<Employee, Applicant> employeeApplicantMap;

    // service
    private static Logger logger;

    static {
        queue = new OfficeQueue();
        createApplicants();
        createEmployees();


        employeeApplicantMap = new HashMap<>();

        logger = Logger.getLogger(DeansofficeApplication.class.getName());

    }

    // methods
    private static void prepareEmployeesForTour() {
        employees.forEach(employee -> employee.setEnergyLeft(EMPLOYEE_ENERGY));
    }

    private static void createApplicants() {
        IntStream.rangeClosed(1, NUM_OF_APPLICANTS).forEach(i -> {
            Applicant ap = RandomApplicantFactory.getRandomApplicant();
            queue.add(ap);
        });
    }

    private static void createEmployees() {
        IntStream.rangeClosed(1, NUM_OF_EMPLOYEES).forEach(i -> {
            Employee e = new Employee(null);
            e.setName(e.hashCode()+"");
            employees.add(e);
        });
    }

    private static Optional<Employee> findFreeEmployee(List<Employee> employees) {
        return employees.stream().filter(employee -> !employee.isBusy()).findFirst();
    }

    private static List<Employee> getEmployeesThatCanWork() {
        return employees
                .stream()
                .filter(employee -> employee.getEnergyLeft() > 0)
                .collect(Collectors.toList());
    }

    private static List<Employee> getBusyEmployees() {
        return employees.stream()
                .filter(employee -> employee.isBusy())
                .collect(Collectors.toList());
    }

    private static void assignEmployeeToApplicantIfPossible(Employee employee) {
        // free employee was found, check if he has enough energy for applicant's new task
        Applicant applicant = queue.peek();

        List<Task> tasks = applicant.getTasks();

        Task currentTask = tasks.get(0);

        int taskDifficulty = currentTask.getDifficulty();

        int energyLeft = employee.getEnergyLeft();

        if (taskDifficulty >= energyLeft) {
            queue.remove();
            employeeApplicantMap.put(employee, applicant);
            employee.setBusy(true);
            // dean special case
        }
    }

    public static void main(String[] args) {
        SpringApplication.run(DeansofficeApplication.class, args);

        // main queue loop, continue while it's not empty
        while (!queue.isEmpty()) {
            logger.log(Level.INFO, "Remaining in queue: " + queue.getQueue().size());

            // continue as long as every employee isn't out of energy
            List<Employee> employeesThatCanWork = getEmployeesThatCanWork();

            while (!employeesThatCanWork.isEmpty() && !queue.isEmpty()) {

                employeesThatCanWork.forEach(employee -> {

                    // employee is busy, as in there's an applicant assigned to him - continue working with him
                    if (employee.isBusy()) {
                        Applicant applicant = employeeApplicantMap.get(employee);

                        List<Task> taskCopy = applicant.getTasks();

                        if (taskCopy.size() > 0) {//
                            Task task = applicant.getTasks().get(applicant.getTasks().size() - 1);
                            logger.log(Level.INFO, employee.getName() + " still helping " + applicant.getName() + ", new task has difficulty " + task.getDifficulty());

                            if (employee.getEnergyLeft() > task.getDifficulty()) {
                                // work
                                employee.setEnergyLeft(employee.getEnergyLeft() - task.getDifficulty());


                                    taskCopy.remove(taskCopy.size() - 1);
                                    applicant.setTasks(taskCopy);
                            } else {
                                // employee is too tired, set his energy to 0 anyway
                                employee.setEnergyLeft(0);
                                employee.setBusy(false);
                            }
                        } else {//
                        employee.setBusy(false);
                        employeeApplicantMap.remove(employee);

                        //
                    }

                    } else {
                        // get a new applicant if possible, assign to map

                        Applicant applicant = queue.peek();
                        if (applicant != null) { // to remove
                            Task task = applicant.getTasks().get(applicant.getTasks().size() - 1);

                            logger.log(Level.INFO, employee.getName() + " now helping " + applicant.getName() + " with task of difficulty " + task.getDifficulty());


                            if (employee.getEnergyLeft() > task.getDifficulty()) {
                                // work
                                queue.remove();
                                employee.setEnergyLeft(employee.getEnergyLeft() - task.getDifficulty());
                                employee.setBusy(true);
                                employeeApplicantMap.put(employee, applicant); // assign employee to applicant

                                List<Task> taskCopy = applicant.getTasks();

                                if (taskCopy.size() > 0) {
                                    taskCopy.remove(taskCopy.size() - 1);
                                    applicant.setTasks(taskCopy);
                                } else {
                                    employee.setBusy(false);
                                    employeeApplicantMap.remove(employee);
                                }

                            } else {
                                employee.setEnergyLeft(0);
                            }

                        } // to remove

                    }
                });


                employeesThatCanWork = getEmployeesThatCanWork();
            }


            // the tour is over, reset energies
            prepareEmployeesForTour();
        }


//        // logic for employees with assigned applicants, complete tasks and subtract energy
//        getBusyEmployees().forEach(employee -> {
//            Applicant applicantForEmployee = employeeApplicantMap.get(employee);
//
//            Task currentTask = null;
//            List<Task> tasks = applicantForEmployee.getTasks();
//            if (tasks.size() > 0) {
//                currentTask = tasks.get(0);
//            }
//
//        });


    }
}
